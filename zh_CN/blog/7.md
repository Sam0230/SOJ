# 本博客暂时未完成，所以不接受issue和pull request



### 7. 评测任务分配与

[代码](7/代码)



《从内核开始 1》之后的又一次重头戏！

<br />

数据库，这个不用说。就是接收请求，写入或查询，返回

一台评测机最多同时测(CPU数 - 2)个测试点，否则会导致多个被测程序互相争抢CPU资源，测试结果出现随机性。

如果我们每次将一次评测分配给一台机器，那么这台机器必须先测前几个测试点，结束后再测后几个，而其他空闲评测机仍然在等待任务，却不能分担一下之前那台评测机的任务。

如果要实现真正的无排队评测，我们必须按照测试点分配任务。

评测任务分配很简单：把一次测试任务拆成子任务，然后把子任务加到子任务数组中。

每50ms扫描一遍子任务数组，把每个子任务的下一个测试点加如评测数组中，如果无下一个测试点说明这个子任务AC了，删除并告诉数据库结果，扫描完毕后再扫描一遍评测数组，将其中的测试点分配给评测端。

如果收到来自评测端的测试结果消息：AC了，就把结果放入所属子任务；未AC，仍把结果放入所属子任务，但然后将子任务删除，且告诉数据库这个子任务的结果。

但是大多数题没有子任务，怎么办？假设它有n个测试点，则“制造”n个“没有子任务时才会有子任务”，使第i个子任务中只有一个测试点，即第i个测试点。

由于要接收任务并和数据库通信，所以我们继续用Node.js做。

JavaScript是一种原生异步的语言，因此它饱受赞扬；但它又不提供同步，这点使它饱受诟病。我们的程序正好要用的同步，可是JSON RPC天生是异步的。怎么办？

最朴素的想法是：在`while (true)`中检查异步操作是否结束。我试了一下，结果很不好。第二次中就说了，Node.js是基于事件循环的。`while (true)`只会占满任务队列，卡住其他任务。这样即使等上一年也没有结果。

我们需要改进。既然循环会占满队列，那么循环一次，运行下一组tick，再运行下一个任务，再继续循环不就解决了吗？

为了访问V8解释器，我们需要使用C++编写插件，在插件中不断运行下一组tick并`uv_run(uv_default_loop(), UV_RUN_ONCE);`，然后检查Buffer共享内存中是否有停止标记。如果有标记或事件循环死亡，就退出。

基于这种思路，我们可以写出一种带有attach功能的Promise。

代码见7/代码/SyncPromise。

以上方法在v11.0以上测试通过，以下的仍然不能正常工作。原因如下：
>任务分为两种，一种是宏任务，一种是微任务。它们各自有各自的队列。一个宏任务在执行的过程中，是可以添加一些微任务的。
就像在柜台办理业务，你前边的一位老大爷可能在存款，在存款这个业务办理完以后，柜员会问老大爷还有没有其他需要办理的业务。
这时老大爷想了一下，我是不是要办理个稳一些的理财呢，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。
所以本来快轮到你来办理业务，会因为老大爷临时添加的“理财业务”而往后推。
也许老大爷在办完理财以后还想 再办一个信用卡？或者 再买点儿纪念币？
无论是什么需求，只要是柜员能够帮他办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。如果老大爷一直不走，那你永远无法办理业务。

所以，我们需要`process._tickCallback()`一下。这样就可以同时支持v11.0以上和以下的版本。

编译问题，我想，可以先预处理代码，然后正式编译。预处理时用ptrace读取打开文件的参数，发现cc1打开源代码、头文件以外的任何文件，直接把参数改成`/dev/null`，正式编译时控制一下时间。这样就可以免去chroot沙箱。

具体方法，见外国大佬的[Playing with ptrace, Part 1](https://www.linuxjournal.com/article/6100)和[Playing with ptrace, Part 2](https://www.linuxjournal.com/article/6210)（需要一定的英语水平）。

关于x86_64和i386汇编的基础，见[ym65536 - x86_64汇编基础](https://www.cnblogs.com/ym65536/p/4542646.html)。

结合两篇文章，我们可以发现，大佬的代码只能在i386下运行，且参数位置有问题；`ym65536 - x86_64汇编基础`的寄存器介绍里说i386有r8d和r9d，但实际没有。所以我做了一个ptrace_reverse_output.cpp（也使用了一些资料中的代码，所以有点乱）。如果用它来运行HelloWorld，你会发现输出变成了`\n!dlroW ,olleH`。

顺便修复了一下核心里的一个小bug（在有大量输出时卡死）。

###### 2019.07.28