# 本博客暂时未完成，所以不接受issue和pull request



### 7. 评测任务分配与

[代码](7/代码)



《从内核开始 1》之后的又一次重头戏！

<br />

数据库，这个不用说。就是接收请求，写入或查询，返回

一台评测机最多同时测(CPU数 - 2)个测试点，否则会导致多个被测程序互相争抢CPU资源，测试结果出现随机性。

如果我们每次将一次评测分配给一台机器，那么这台机器必须先测前几个测试点，结束后再测后几个，而其他空闲评测机仍然在等待任务，却不能分担一下之前那台评测机的任务。

如果要实现真正的无排队评测，我们必须按照测试点分配任务。

评测任务分配很简单：把一次测试任务拆成子任务，然后把子任务加到子任务数组中。

每50ms扫描一遍子任务数组，把每个子任务的下一个测试点加如评测数组中，如果无下一个测试点说明这个子任务AC了，删除并告诉数据库结果，扫描完毕后再扫描一遍评测数组，将其中的测试点分配给评测端。

如果收到来自评测端的测试结果消息：AC了，就把结果放入所属子任务；未AC，仍把结果放入所属子任务，但然后将子任务删除，且告诉数据库这个子任务的结果。

但是大多数题没有子任务，怎么办？假设它有n个测试点，则“制造”n个“没有子任务时才会有子任务”，使第i个子任务中只有一个测试点，即第i个测试点。

由于要接收任务并和数据库通信，所以我们继续用Node.js做。

编译沙箱问题，我想，可以先预处理代码，然后正式编译。预处理时用ptrace读取打开文件的参数，发现cc1打开源代码、头文件以外的任何文件，直接把参数改成`/dev/null`，正式编译时控制一下时间。这样就可以免去chroot沙箱。

具体方法，见外国大佬的[Playing with ptrace, Part 1](https://www.linuxjournal.com/article/6100)和[Playing with ptrace, Part 2](https://www.linuxjournal.com/article/6210)（需要一定的英语水平）。

关于x86_64和i386汇编的基础，见[ym65536 - x86_64汇编基础](https://www.cnblogs.com/ym65536/p/4542646.html)。

结合两篇文章，我们可以发现，大佬的代码只能在i386下运行，且参数位置有问题；`ym65536 - x86_64汇编基础`的寄存器介绍里说i386有r8d和r9d，但实际没有。所以我做了一个ptrace_reverse_output.cpp（也使用了一些资料中的代码，所以有点乱）。如果用它来运行HelloWorld，你会发现输出变成了`\n!dlroW ,olleH`。

顺便修复了一下核心里的一个小bug（在有大量输出时卡死）。

###### 2019.07.28