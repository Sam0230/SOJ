### 6. 数据库

[代码](6/代码)

数据库，要做的就是接收请求，写入或查询，返回。

在数据储存这个方面，我们有两种选择：1. 使用现成的数据库软件；2. 自己写一个。

自己写的灵活性更大一些，可以更贴合用途。所以我们选择自己写。

在查找和写入方面，最快的无疑是树形结构了。树形结构中比较好的有三种：文件系统 XML JSON。

只要看到过电脑的人都知道，电脑里的文件是通过文件和文件夹储存的，就是文件系统。文件系统内部是二进制方式的储存，速度快，耗费体积小，所有语言的程序都可以直接读取，人类需要通过文件管理器可以很轻松地直接查看。

许多数据都是通过XML来储存的，比如网页。XML通过文字储存，查询时需要遍历要查询区域前的所有内容，速度慢，压缩成一行后耗费体积小，转义不完全，不分数据类型，不适合人类直接查看，也不适合程序读取。

JSON也通过文字储存，查询时也需要遍历要查询区域前的所有内容，速度慢，压缩成一行后耗费体积略小于XML，格式化后人类可以直接查看，适合JavaScript语言的读取。

我们得出答案：文件系统。

我们的数据库客户端程序要同步等待服务端返回结果，可是JSON RPC天生是异步的。怎么办？

最朴素的想法是：在`while (true)`中检查异步操作是否结束。我试了一下，结果很不好。第二次中就说了，Node.js是基于事件循环的。`while (true)`只会占满任务队列，卡住其他任务。这样即使等上一百年也不会有结果。

我们需要改进。既然循环会占满队列，那么循环一次，运行下一组tick，再运行下一个任务，再继续循环不就解决了吗？

为了访问V8解释器，我们需要使用C++编写插件，在插件中不断运行下一组tick并`uv_run(uv_default_loop(), UV_RUN_ONCE);`，然后检查Buffer共享内存中是否有停止标记。如果有标记或事件循环死亡，就退出。

然后用JS写个包装，把它整合进Promise。

基于这种思路，我们可以写出一种带有attach功能的Promise。我顺便用类似的方法写了sleep和msleep函数。

代码见[6/代码/SyncPromise](6/代码/SyncPromise)。（demo.js的注释和输出是英文的，且需要自己编译一下C++模块）

有了这个，数据库就很简单了——先写一个read功能，剩余的“复制粘贴大法好”。

代码见[6/代码/database](6/代码/database)。

###### 2019.07.28~08.07（在这期间我的姐姐生了一个宝宝，我们一家都很忙，所以拖的时间有点长）